# 3. Spring Security 기본 로직 이해하기

> 우선 이 글에서는 Spring Security의 전체 동작 원리만 정리해보았다. 그리고 다음 글에서 기능 단위(회원 가입/로그인/권한 처리)로 자세히 정리해보았다.



### Spring Security 로직

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption><p>Spring Security</p></figcaption></figure>

스프링 시큐리티는 필터 체인이다. 전체 요청이 서블릿으로 보내지기 전에 시큐리티가 동작한다. 로그인은 전체 어플리케이션 시작전에 항상 이루어져야 하므로, 필터(시큐리티)를 통해 로그인 인증을 한다.

시큐리티는 여러 인터페이스들을 거쳐 진행된다. 각각의 인터페이스를 상속받아서 Custom하여 구현할 수 있다. 시큐리티를 사용하면 스프링만으로 구현할 때보다 **로그인 페이지로 이동/인증/권한 처리**를 쉽게 할 수 있다. 일단 각각의 인터페이스의 역할을 글로 간단히 정리하면 다음과 같다.

1. **AuthenticationFilter** : 필터 등록하고, 이미 로그인 세션이 있는지 세션 ID로 SecurityContextHolder에서 확인한다.
2. **AuthenticationManager** : 입력받은 정보로 Authentication 객체를 생성한다. Manager에 Provider를 등록해주어야 다음 로직으로 진행된다.
3. **AuthenticationProvider** : 입력받은 Authentication 객체와 DB의 User 객체가 같은 지 검증한다.
4. **UserDetailsService** : DB 접근해서 User 정보 가져온다. (Repository을 통해 DB 접근)
5. **UserDetails** : User 정보를 담고 있다.

**각각은 인터페이스이므로, 추상 메소드를 가진다. 인터페이스를 상속받아 추상 메소드를 오버라이딩하여 각자 프로젝트에 맞게 구현해주면 된다.** 우선 이 글에서는 각 인터페이스의 코드를 정리해보고, 다음 글에서 기능(회원가입/로그인/권한처리) 위주로 코드를 다시 정리해보았다.

위의 모든 인터페이스를 상속받아서 Custom하여 구현해줄 수도 있지만, 여기서는 시큐리티의 흐름을 간단히 알아보기 위해 이 프로젝트에서 필요한 인터페이스(**`AuthenticationProvider, UserDetailsService, UserDetails`**)들만 직접 구현헤보았다. 글에 올린 코드는 설명을 위해 일부만 첨부했고, 전체 코드는 [깃허브](https://github.com/f-lab-edu/book-club/compare/feat/login-security-sy)에 있다.



### SpringSecurityConfig

`@EnableWebSecurity`으로 `SpringSecurityFilterChain`에 등록해줄 수 있다.

```java
@Configuration
@EnableWebSecurity // SpringSecurityFilterChain 에 등록
@RequiredArgsConstructor
public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {
    // ...
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().authorizeRequests()
                .antMatchers("/login", "/join").permitAll()     // 모두 접근 가능
                .antMatchers("/admin").hasRole("ADMIN")         // ADMIN 만 접근 가능
                .antMatchers("/main").authenticated()           // 인증해야 접근 가능
                /* 로그인 폼 */
                .and().formLogin()
                .loginPage("/login")
                .usernameParameter("name")
                .passwordParameter("password")
                .defaultSuccessUrl("/main")   // 성공 시 /main
                .failureUrl("/fail")          // 실패 시 /fail
                .permitAll()
		// ...
    }
    // Manager 에 Provider 등록
    @Override
    public void configure(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {
        authenticationManagerBuilder.authenticationProvider(customAuthenticationProvider());
    }

    // Provider 생성
    @Bean
    public CustomAuthenticationProvider customAuthenticationProvider() {
        return new CustomAuthenticationProvider(userDetailsService, bCryptPasswordEncoder());
    }
    // ...
```

1. **AuthenticationFilter**
2. **AuthenticationManager**

이 두가지는 따로 Custom해주지 않았다. 대신 SpringSecurityConfig을 보면, `AuthenticationManagerBuilder`를 통해 **Manager에 Provider을 등록해주는 걸 볼 수 있다.**

{% embed url="https://github.com/f-lab-edu/book-club/commit/e619536c4eccd6b2cd6beaae9197f704ade530e9" %}
[SpringSecurityConfig 설정](https://github.com/f-lab-edu/book-club/commit/e619536c4eccd6b2cd6beaae9197f704ade530e9)
{% endembed %}

****

### 3. **AuthenticationProvider**

AuthenticationProvider을 상속받아 `CustomAuthenticationProvider`을 구현하였다.

`authenticate()`는 입력받은 Authentication 객체와 DB의 User 객체의 아이디/비번이 같은지 확인하는 메소드이다. `CustomAuthenticationProvider`에서는 이 메소드를 자기 프로젝트에 맞게 구현하면 된다. (이 프로젝트에서 아이디는 name이다.)

<pre class="language-java"><code class="lang-java">public class CustomAuthenticationProvider implements AuthenticationProvider {
<strong>    // ...	
</strong>    // 인증 메소드
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {

        String name = authentication.getName();
        String password = (String) authentication.getCredentials();

        User user = (User) userDetailsService.loadUserByUsername(name);

        if (!passwordEncoder.matches(password, user.getPassword())) {
            throw new BadCredentialsException(user.getUsername() + "비밀번호를 다시 입력해주세요.");
        }
        return new UsernamePasswordAuthenticationToken(user, user.getPassword(), user.getAuthorities());
    }
    // ...
}</code></pre>

{% embed url="https://github.com/f-lab-edu/book-club/commit/fb1e0d6148b47cf1f1482aa0e40b1a26ef5743ec" %}
AuthenticationProvider의 구현체 생성
{% endembed %}



### 4. **UserDetailsService**

UserDetailsService을 상속받아 `CustomUserDetailsService`을 구현하였다.

`loadUserByUsername()`는 DB에 접근하여 User 객체를 가져오는 메소드이다. 이 또한 각자의 프로젝트에 맞게 오버라이딩해주면 된다.

```java
public class CustomUserDetailsService implements UserDetailsService {
    // ...
    @Override
    public UserDetails loadUserByUsername(String name) {

        User user = userRepository.findByName(name);
        if (user == null) {
            throw new UsernameNotFoundException("Can't find user");
        }
        return user;
    }
}
```

{% embed url="https://github.com/f-lab-edu/book-club/commit/ef9b525d387d789719f959415a58d295a62e4649" %}
UserDetailsService
{% endembed %}



### 5. UserDetails

UserDetails를 상속 받아 엔티티 User을 구현했다. UserDetails의 추상 메소드들,

* `getAuthorities`
* `getUsername`
* `isAccountNonExpired`

등등 오버라이딩해서 구현해주었다.

{% embed url="https://github.com/f-lab-edu/book-club/commit/37f3f54b6fe8ef09ce07f650d8c5425d4b876eac" %}
UserDetails 의 구현체(User) 생성
{% endembed %}

다음 글에서는 기능 단위(회원 가입/로그인/권한 처)로 로직과 코드를 정리해보았다.

